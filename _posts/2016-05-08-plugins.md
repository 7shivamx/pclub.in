---
layout: post
title: "Vim Plugins"
date: 2016-05-08 13:02:20 +0530
author: Yash Srivastav
website: http://yashsriv.github.io
category: 
tags: 
- vim
- tutorial
categories:
- tutorial
- vim

image:
  url: https://vim.sexy/img/Vimlogo.svg

---

# Plugins!!

Vim is a very simple text-based Text-Editor which can be transformed into a powerful IDE using plugins.
This is the first of many posts I'll write about vim plugins one at a time and how to set them up fully for a truly satisfying
experience( custom tailored to *your* requirements ).

The first step to using vim plugins is finding them. You can find a list of trending vim plugins at [vimawesome](http://vimawesome.com).
Once you find a plugin, you have to install it. Most plugins have a README.md which you should read carefully before deciding to use them.
  > Maybe it requires an external dependency  
  > Maybe it needs a particular version of vim  
  > Maybe it requires NeoVim  

After deciding upon that, installation needs to be done via a plugin manager like [Pathogen](https://github.com/tpope/vim-pathogen) or
[Vundle](https://github.com/VundleVim/Vundle.vim) or [Neobundle](https://github.com/Shougo/neobundle.vim) or
[Vim-plug](https://github.com/junegunn/vim-plug) or [dein](https://github.com/Shougo/dein.vim) ...

So now starting upon my theme of taking one plugin at a time and setting it up, let's start with plugin managers. I'll try and highlight
as much as I know about each one of them and the basic efforts you need to take to install a plugin using them. For an example, the plugin we
will be installing alongside the plugin manager is -  
[tern-for-vim](https://github.com/ternjs/tern_for_vim) - It adds support for javascript in vim.  
*tern_for_vim requires nodejs. (This is just an example, you don't need to install this specifically)*
I am choosing this Plugin because it has a build step alongside the usual installation and is valid for only some file types.

So now starting in alphabetical order, Dein.vim

## [Dein](https://github.com/Shougo/dein.vim)

[Dein](https://github.com/Shougo/dein.vim) is the apparent successor of [Neobundle](https://github.com/Shougo/neobundle.vim) both by the same person - `Shougo`.
As per what I wrote previously, you really should check out the homepage, i.e, the README.md
and then decide whether this plugin is for you. For example this requires Vim version > 7.4 so only think
about this if you do have vim version > 7.4. Version can be checked by firing up vim and typing
{% highlight vim %}
:version
{% endhighlight %}
which gives a very verbose description of your vim version.

One of the main reasons why I liked dein is because it supports asynchronous installation/updating of plugins, something which Vundle
or Pathogen do not support. Neobundle provides this with the help of another plugin (vimproc), but I believe inbuilt support is better.

### Installation
This is directly from the [README.md](https://github.com/Shougo/dein.vim)

#### For linux/MacOS:
1. Run this script below:

     {% highlight shell %}
     $ curl https://raw.githubusercontent.com/Shougo/dein.vim/master/bin/installer.sh > installer.sh  
     $ sh ./installer.sh {specify the installation directory}  
     {% endhighlight %}

2. Edit your .vimrc like this.

{% highlight vim %}

" Set vim to work as vim instead of vi
if &compatible
  set nocompatible
endif

" Load dein
set runtimepath^={path to dein.vim directory}

" Location to store installed plugins
call dein#begin(expand('~/.vim/bundle'))

" Add dein as a plugin
call dein#add("Shougo/dein.vim")
...
...

call dein#end()

filetype plugin indent on
...
...
{% endhighlight %}


So to understand whats happening above, let's go step by step.

 * Curl is used to fetch the installation script
 * Installation script is launched with the parameter specifying where to install dein.vim. Let's say `~/.vim/bundle/repos/github.com/Shougo/dein.vim`
 * In your `vimrc`, you add dein to your runtimepath.
 * then you begin dein configuration where every other plugin is specified
 * For installation location, you choose `~/.vim/bundle`. Doing this allows you to just add `Shougo/dein.vim` because that is essentially how `dein` downloads
plugins. For example, if you write `call dein#add("foo/bar.vim")`, `dein` will decide that `bar.vim` is a plugin in the github repo
of `foo` and download the plugin to `~/.vim/bundle/repos/github.com/foo/bar.vim`
 * So now that it is done, let's try installing our target plugin `tern_for_vim`

The structure of the `vimrc` would look like this:

{% highlight vim %}
...
call dein#begin(expand('~/.vim/bundle'))

" Add dein as a plugin
call dein#add("Shougo/dein.vim")

" Add tern_for_vim
call dein#add("ternjs/tern_for_vim", {'on_ft' : ['javascript', 'foobarlang'], 'hook_post_update': 'npm install'})
...
...
call dein#end()
...
...
{% endhighlight %}

So now let's understand what I did there:

* Add `ternjs/tern_for_vim` as a plugin
* Set these plugins to load only for javascript files and foobarlang( a superawesome fictional language that can code the universe!!) files
* If your read the [README.md](https://github.com/ternjs/tern_for_vim/blob/master/README.md) of `tern_for_vim`, it requires `npm install` to be run in its Installation directory once fetched,
so post_update, `npm install` is run in the installation directory. Now fire up vim and execute `:call dein#install()` to install the plugin.

Apart from the two non-default options above, there are many more. So how will you come to know about them???
Read the help docs like I did. Once a plugin is fetched, you are encouraged to read its documentation using
`:help dein` or `:help tern`. Remember that tern_for_vim is loaded only for javascript file types and hence
the documentation will only be available in those files.

Plugins can be updated using `:call dein#update()`. Enlisting dein itself as a plugin ensured even dein is
updated when running this command.  
`:call dein#check_clean()` returns a list of unclean files, i.e., the ones you have stopped using and removed
from your vimrc but their files are still present inside `~/.vim/bundle`. You can easily write a function
to get these files and delete them on call and then call this function for cleaning.

Advantages of using dein.vim:

* Asynchronous Installs supporting NeoVim
* Only Loads relevant plugins for a certain filetype and hence vim starts up faster

Disadvantages:

* Relatively new and very little support
* Help docs might be confusing sometimes due to too many features

## [Neobundle](https://github.com/Shougo/neobundle.vim)

Since dein.vim is the newer version as mentioned [here](https://github.com/Shougo/neobundle.vim/blob/master/README.md),
I'll leave this out as deprecated

## [Pathogen](https://github.com/tpope/vim-pathogen)

One of the oldest plugin managers for vim and hence it is slightly involved.
Pathogen works on the principle that most plugins are available from git repos,
so any git folder in `~/.vim/bundle` is a plugin and hence it needs to be added
to the `runtimepath` so that its data is loaded when vim fires up.

### Installation
Again from the [README.md](https://github.com/tpope/vim-pathogen/blob/master/README.md)

Install to `~/.vim/autoload/pathogen.vim`. Or copy and paste:

{% highlight bash %}
mkdir -p ~/.vim/autoload ~/.vim/bundle
curl -LSso ~/.vim/autoload/pathogen.vim https://tpo.pe/pathogen.vim
{% endhighlight %}

So the minimal `vimrc` looks like this:

{% highlight vim %}
execute pathogen#infect()
syntax on
filetype plugin indent on
{% endhighlight %}

 > Real Minimal..Huh?  

So what this does is, it calls pathogen infect which essentially adds all folders in
the bundle folder to the `runtimepath`. Then syntax highlighting and file type specific
plugins and features are switched on. This is done so that in case the installed plugin
adds support for syntax of a language or has some file type specific features, they are
also used since they have been added to the `runtimepath`.

Now to install our example plugin:  
This time, it requires no changes to the `.vimrc` since it only requires a call to pathogen.
To install the plugin, you will need to manually go to the folder `~/.vim/bundle` and clone
the repo of the required plugin:

{% highlight bash %}
cd ~/.vim/bundle`
git clone https://github.com/ternjs/tern_for_vim
{% endhighlight %}

Now, since this plugin requires the extra step of doing an npm install, you need to do:

{% highlight bash %}
cd ~/.vim/bundle/tern_for_vim/
npm install
{% endhighlight %}

So its essentially done. You might need to generate the help files by calling `:Helptags`
inside vim as mentioned in the README. See the number of steps *you* had to do manually.
Now consider you are going to use 10 plugins. You will need to atleast manually clone it
and if it has a build step, then execute that. And if you need to uninstall, then also manual
deletion with the risk of `rm -rf /`

Even updating needs to be done manually by going into each plugin and calling :  
`git pull origin master`

So coming to the advantages:

* Old and ancient and hence extensive support
* Very clean vimrc

Disadvantages:

* Requires extensive effort from user side( some might consider this an advantage because you actually
learn whats happening inside instead of an abstraction hiding it )
* All plugins are loaded irrespective of filetype
* Asynchronous installs only if you can type asynchronously

**PS:** I maybe wrong in some or all of my assumptions here since I used this for only a very short
time, at a time when I didn't read helptags(a mistake which I regret). If so please correct me in the
comments

## [Vim-Plug](https://github.com/junegunn/vim-plug)

A minimalist plugin manager and the one I use currently. Its features are highlighted at the top of
[README.md](https://github.com/junegunn/vim-plug/blob/master/README.md)

### Installation

Again this involves a single file, plug.vim, which needs to be loaded when Vim starts and hence
it is placed in `~/.vim/autoload`  
`curl -fLo ~/.vim/autoload/plug.vim --create-dirs https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim`

Now to install plugins, you need to add the relevant section in your vimrc. For the example plugin:

{% highlight vim %}
call plug#begin('~/.vim/bundle')
" Use single quotes

Plug 'ternjs/tern_for_vim', {'do': 'npm install', 'for': ['javascript', 'foobarlang']}
...
...
call plug#end()

{% endhighlight %}

Here `~/.vim/bundle` is where the plugins get installed. After adding this to your vimrc, fire up vim and run
`:PlugInstall`. This will start the installation in a side window with a nice progress bar while you can continue editing a file
due to the asynchronous install.

To update plugins, run `:PlugUpdate`

To uninstall a plugin, remove it from your vimrc and run `:PlugClean`

Extensive options are available for customising the experience. Many examples in the README.md
with full documentation available by help.

This takes the concept of loading plugins to another level by having an option to load plugins only when I call a certain function.
For example let there be a plugin X which has a function Y. Now this plugin won't be loaded at vim startup. Instead it will be loaded
when I try to call the function Y.

Advantages:

* Minimal and easy to use
* Highly customisable plugin loading
* Asynchronous install
* On demand plugin loading

Disadvantages:

* None that bother me

## [Vundle](https://github.com/VundleVim/Vundle.vim)

The last but not the least, Vundle. Neobundle was a fork of this
with more features and has now become dein. This is one of the first
plugin managers I used, thanks to [Lakshay](https://lakshayg.github.io) and kept for a long time till I decided to switch
to Vim-Plug.

### Installation

Setting up Vundle:
{% highlight bash %}
$ git clone https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vim
{% endhighlight %}

Configuring Plugins:

This is the minimal `.vimrc` with Vundle installed

{% highlight vim %}
set nocompatible  " Sets vim to behave as vim instead of vi
filetype off      " Required by vundle

" set the runtime path to include Vundle and initialize
set rtp+=~/.vim/bundle/Vundle.vim
call vundle#begin()
" alternatively, pass a path where Vundle should install plugins
"call vundle#begin('~/some/path/here')

"let Vundle manage Vundle, required
Plugin 'VundleVim/Vundle.vim'
...
" All plugins should be added before this line
call vundle#end()        " required
filetype plugin indent on
syntax enable
{% endhighlight %}

#### Installing the sample plugin

Put the following line in the `.vimrc` between `vundle#begin` and `vundle#end`:

{% highlight vim %}
Plugin 'ternjs/tern_for_vim'
{% endhighlight %}

Now fire up vim and execute `:PluginInstall` to install this plugin.

As you know by now, this plugin has an extra build step which has not been addressed
in any way in the `.vimrc`. Hence you need to manually run `npm install`.

{% highlight vim %}
$ cd ~/.vim/bundle/tern_for_vim/
$ npm install
{% endhighlight %}

The reason why I shifted from **Vundle** to **VimPlug** was because of its synchronous(blocking)
install with no feedback on progress.

Advantages:

* Simple
* Automated updation and helptags generation

Disadvantages:

* Blocking installs and updates
* No post installation hooks
* Loads all plugins irrespective of filetype

## Ending

If you are a beginner in vim, I would suggest Vundle or Vim-Plug.
Pathogen is too ancient and dein.vim is too complex. On a personal note,
use vim plug as it has a simple interface for beginners and as and when you
grow more experienced, you can fine tune your plugins using it. Even the
pclub cordis use vim-plug. See [here](https://github.com/sakshamsharma/vivid-vim/blob/master/vimfiles/plugins.vim)
and [here](https://github.com/kunalapila/vimrc/blob/master/.vimrc)

## PS

I consider myself a novice in vim with only 30-40% knowledge. So if my views seem
biased towards Vundle or Vim-plug its because I used them. If there are any errors here,
feel free to correct me in the comments.

## PPS

This turned out to be quite verbose(2129 words!!) but its only because there are so many options for plugins managers.
Next time onwards, I promise I will focus on a single power plugin and its usage.(Except for autocompletion plugins,
since there are so many of them too)
